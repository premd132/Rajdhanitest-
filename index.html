/* IMPROVED SEARCH LOGIC */
function searchPattern(shape, base) {
    lastMatches = [];
    let h = shape.length;

    // Poore data mein scan karein
    for (let i = 0; i <= data.length - h; i++) {
        let score = 0;
        let totalActiveSpots = 0;

        for (let k = 0; k < h; k++) {
            for (let j = 0; j < 6; j++) {
                if (shape[k][j]) { // Agar pattern ka part hai
                    totalActiveSpots++;
                    // Check karein ki kya wahan base ki family ka koi member hai
                    if (smartMatch(data[i + k][j], base)) {
                        score++;
                    }
                }
            }
        }

        // Agar saare spots match ho gaye
        if (score === totalActiveSpots && totalActiveSpots > 0) {
            // "Aas-paas" logic: Check secondary matches in the same block
            // Isse result ki accuracy badh jayegi
            lastMatches.push({ index: i });
        }
    }
    showChecks(shape);
    // AI Suggestions ko bhi call karein
    if(lastMatches.length > 0) showAISuggestions(shape);
}

/* AI IMPROVEMENT: Isme ab aas-paas ki family ka weightage zyada hai */
function showAISuggestions(shape) {
    let pool = [], h = shape.length;
    
    topMatches.forEach(m => {
        let nextRowIdx = m.index + h; 
        if (nextRowIdx < data.length) {
            let val = data[nextRowIdx][targetCol];
            if (val !== "**") pool.push(val);
            
            // Side columns bhi check karein (Left/Right)
            if(targetCol > 0) pool.push(data[nextRowIdx][targetCol-1]);
            if(targetCol < 5) pool.push(data[nextRowIdx][targetCol+1]);
        }
    });

    if (!pool.length) { future.innerHTML = "No enough data for prediction"; return; }

    let jc = {}, dc = {};
    pool.forEach(v => {
        if(v === "**") return;
        jc[v] = (jc[v] || 0) + 1;
        dc[v[0]] = (dc[v[0]] || 0) + 1;
        dc[v[1]] = (dc[v[1]] || 0) + 1;
    });

    let fJ = Object.entries(jc).sort((a, b) => b[1] - a[1]).slice(0, 3).map(x => x[0]).join(", ");
    let fD = Object.entries(dc).sort((a, b) => b[1] - a[1]).slice(0, 2).map(x => x[0]).join(", ");

    future.innerHTML = `<b>Strong Jodi:</b> ${fJ}<br><b>Single Ank:</b> ${fD}`;
}
